# MCP Server Operational Model Documentation

**Status:** ‚úÖ COMPLETED
**Created:** 2025-12-30
**Last Updated:** 2025-12-30
**Purpose:** Document the operational model based on Crackerjack and Session-Buddy contracts

______________________________________________________________________

## üéØ Executive Summary

This document establishes the operational model for all MCP server migrations to Oneiric, based on the Crackerjack CLI/lifecycle contract and Session-Buddy health schema contract. It serves as the authoritative reference for how MCP servers should operate after migration.

### Operational Model Principles

1. **Crackerjack Compliance:** Follow Crackerjack's Oneiric migration patterns
1. **Session-Buddy Health:** Use Session-Buddy's health schema primitives
1. **No Legacy Support:** Remove all legacy CLI flags and ACB patterns
1. **Standardization:** Consistent operational behavior across all MCP servers
1. **Observability:** Comprehensive health and telemetry reporting

______________________________________________________________________

## üìã Crackerjack Operational Contract

### Source References

**Primary Sources:**

- `crackerjack/docs/MIGRATION_GUIDE_0.47.0.md`
- `crackerjack/docs/reference/BREAKING_CHANGES.md`
- `crackerjack/docs/archive/implementation-plans/ONEIRIC_MIGRATION_EXECUTION_PLAN.md`

### CLI Command Contract

**Mandatory Commands:**

```bash
# Standard lifecycle commands
project-mcp start      # Start the MCP server
project-mcp stop       # Stop the running server
project-mcp restart    # Restart the server
project-mcp status     # Show server status
project-mcp health     # Health check endpoint
project-mcp health --probe  # Live health probe
```

**Command Semantics:**

- **Subcommand Syntax:** Use `start`, `stop`, etc. (not `--start`, `--stop`)
- **No Legacy Flags:** Remove all legacy flag-based commands
- **Instance Isolation:** Support `--instance-id <id>` for multi-instance deployments
- **Exit Codes:** Standard exit codes (0=success, 1=error, 2=invalid usage)
- **Help Output:** Auto-generated by Oneiric CLI factory

### Runtime Cache Contract

**Cache Structure:**

```
.oneiric_cache/
‚îú‚îÄ‚îÄ server.pid                  # PID file (current instance)
‚îú‚îÄ‚îÄ runtime_health.json         # Health snapshot (cached)
‚îú‚îÄ‚îÄ runtime_telemetry.json      # Telemetry data
‚îî‚îÄ‚îÄ <instance-id>/              # Multi-instance support
    ‚îú‚îÄ‚îÄ server.pid
    ‚îú‚îÄ‚îÄ runtime_health.json
    ‚îî‚îÄ‚îÄ runtime_telemetry.json
```

**Cache File Requirements:**

1. **PID File:** `server.pid` containing process ID
1. **Health Snapshot:** `runtime_health.json` with mcp-common health schema
1. **Telemetry:** `runtime_telemetry.json` with performance metrics
1. **Instance Isolation:** Per-instance cache folders when `--instance-id` is used

### Status Command Behavior

**Status Command Requirements:**

- Read `.oneiric_cache/server.pid` for process status
- Read `.oneiric_cache/runtime_health.json` for health status
- Read `.oneiric_cache/runtime_telemetry.json` for metrics
- Return JSON with comprehensive status information

**Status Output Schema:**

```json
{
  "status": "running",
  "pid": 12345,
  "uptime": "1h 23m 45s",
  "health": {
    "status": "HEALTHY",
    "timestamp": "2025-12-30T12:00:00Z"
  },
  "metrics": {
    "requests_processed": 42,
    "errors_encountered": 0,
    "average_response_time_ms": 120
  }
}
```

### Health Command Behavior

**Health Command Requirements:**

- `health`: Read cached `runtime_health.json` (passive)
- `health --probe`: Perform live health checks (active)
- Both return same schema but `health --probe` must be live
- Use mcp-common health schema primitives

**Health Command Differences:**
| Command | Source | Use Case |
|---------|--------|----------|
| `health` | Cache file | Monitoring dashboards, status checks |
| `health --probe` | Live checks | Production monitoring, systemd integration |

______________________________________________________________________

## üè• Session-Buddy Health Schema Contract

### Source References

**Primary Sources:**

- `session-buddy/docs/reference/API_REFERENCE.md`
- `mcp-common/health.py`

### Health Schema Primitives

**Required Imports:**

```python
from mcp_common.health import HealthStatus, ComponentHealth, HealthCheckResponse
```

### Health Status Enum

**HealthStatus Values:**

```python
class HealthStatus(str, Enum):
    HEALTHY = "HEALTHY"      # All systems operational
    DEGRADED = "DEGRADED"    # Partial functionality, some issues
    UNHEALTHY = "UNHEALTHY"  # Critical failure, not operational
```

### Component Health Schema

**ComponentHealth Fields:**

```python
class ComponentHealth(BaseModel):
    name: str                          # Component identifier
    status: HealthStatus               # Current status
    message: str                       # Human-readable status
    latency_ms: Optional[float] = None # Response time (if applicable)
    metadata: Optional[dict] = None    # Additional context
```

### Health Check Response Schema

**HealthCheckResponse Fields:**

```python
class HealthCheckResponse(BaseModel):
    status: HealthStatus               # Overall status (worst component)
    components: List[ComponentHealth]  # Individual component statuses
    timestamp: str                     # ISO 8601 timestamp
```

### Health Status Determination

**Status Calculation:**

- Overall status = worst component status
- Priority: UNHEALTHY > DEGRADED > HEALTHY
- If any component is UNHEALTHY, overall is UNHEALTHY
- If any component is DEGRADED (and none UNHEALTHY), overall is DEGRADED
- If all components are HEALTHY, overall is HEALTHY

### Example Health Response

**Healthy Example:**

```json
{
  "status": "HEALTHY",
  "components": [
    {
      "name": "database",
      "status": "HEALTHY",
      "message": "Database connection established",
      "latency_ms": 50.2,
      "metadata": {
        "connection_string": "postgresql://...",
        "query_time_ms": 25.1
      }
    },
    {
      "name": "api_client",
      "status": "HEALTHY",
      "message": "External API client operational",
      "latency_ms": 120.5,
      "metadata": {
        "api_version": "v3",
        "rate_limit_remaining": 950
      }
    }
  ],
  "timestamp": "2025-12-30T12:00:00.123456Z"
}
```

**Degraded Example:**

```json
{
  "status": "DEGRADED",
  "components": [
    {
      "name": "database",
      "status": "HEALTHY",
      "message": "Database connection established",
      "latency_ms": 50.2
    },
    {
      "name": "api_client",
      "status": "DEGRADED",
      "message": "External API rate limited",
      "latency_ms": 120.5,
      "metadata": {
        "api_version": "v3",
        "rate_limit_remaining": 50,
        "retry_after_seconds": 30
      }
    }
  ],
  "timestamp": "2025-12-30T12:00:00.123456Z"
}
```

**Unhealthy Example:**

```json
{
  "status": "UNHEALTHY",
  "components": [
    {
      "name": "database",
      "status": "UNHEALTHY",
      "message": "Database connection failed",
      "latency_ms": null,
      "metadata": {
        "error": "connection_timeout",
        "last_error": "ETIMEDOUT: Connection timeout"
      }
    },
    {
      "name": "api_client",
      "status": "HEALTHY",
      "message": "External API client operational",
      "latency_ms": 120.5
    }
  ],
  "timestamp": "2025-12-30T12:00:00.123456Z"
}
```

______________________________________________________________________

## üîß Operational Model Implementation

### Oneiric CLI Factory Integration

**Standard Implementation:**

```python
# project/__main__.py
from oneiric.core.cli import MCPServerCLIFactory
from project.server import ProjectMCPServer
from project.config import ProjectConfig

def main():
    cli_factory = MCPServerCLIFactory(
        server_class=ProjectMCPServer,
        config_class=ProjectConfig,
        name="project-mcp",
        description="Project MCP Server",
        version="1.0.0",
        # Crackerjack compliance: subcommand syntax
        use_subcommands=True,  # Required by Crackerjack
        legacy_flags=False,    # Required by Crackerjack
        # Session-Buddy health integration
        health_schema="mcp_common.health"  # Required by Session-Buddy
    )
    cli_factory.run()

if __name__ == "__main__":
    main()
```

### Server Class Implementation

**Standard Server Pattern:**

```python
# project/server.py
from oneiric.core.server import OneiricMCPServer
from oneiric.core.runtime import RuntimeSnapshotManager
from mcp_common.health import HealthStatus, ComponentHealth, HealthCheckResponse
from project.config import ProjectConfig
from typing import Optional

class ProjectMCPServer(OneiricMCPServer):
    def __init__(self, config: ProjectConfig, instance_id: Optional[str] = None):
        super().__init__(config, instance_id=instance_id)
        self.snapshot_manager = RuntimeSnapshotManager(instance_id)
        # Project-specific initialization

    async def on_startup(self):
        await super().on_startup()
        # Initialize runtime snapshots (Crackerjack requirement)
        await self.snapshot_manager.initialize()
        # Project-specific startup

    async def on_shutdown(self):
        # Project-specific cleanup
        await super().on_shutdown()
        # Clean up runtime snapshots
        await self.snapshot_manager.cleanup()

    async def health_check(self) -> HealthCheckResponse:
        """
        Implement Session-Buddy health schema
        """
        # Check individual components
        components = []

        # Database health check
        db_status = HealthStatus.HEALTHY
        db_message = "Database connection established"
        db_latency = None
        db_metadata = {}

        try:
            # Test database connection
            db_latency = await self._test_database_connection()
            db_metadata["connection_time_ms"] = db_latency
        except Exception as e:
            db_status = HealthStatus.UNHEALTHY
            db_message = f"Database connection failed: {str(e)}"
            db_metadata["error"] = str(e)

        components.append(ComponentHealth(
            name="database",
            status=db_status,
            message=db_message,
            latency_ms=db_latency,
            metadata=db_metadata
        ))

        # API client health check
        api_status = HealthStatus.HEALTHY
        api_message = "API client operational"
        api_latency = None
        api_metadata = {}

        try:
            # Test API client
            api_latency = await self._test_api_client()
            api_metadata["response_time_ms"] = api_latency
        except Exception as e:
            api_status = HealthStatus.DEGRADED
            api_message = f"API client degraded: {str(e)}"
            api_metadata["error"] = str(e)

        components.append(ComponentHealth(
            name="api_client",
            status=api_status,
            message=api_message,
            latency_ms=api_latency,
            metadata=api_metadata
        ))

        # Determine overall status (Session-Buddy requirement)
        overall_status = HealthStatus.HEALTHY
        if any(c.status == HealthStatus.UNHEALTHY for c in components):
            overall_status = HealthStatus.UNHEALTHY
        elif any(c.status == HealthStatus.DEGRADED for c in components):
            overall_status = HealthStatus.DEGRADED

        # Create health response (Session-Buddy schema)
        return HealthCheckResponse(
            status=overall_status,
            components=components,
            timestamp=self._get_current_timestamp()
        )

    async def _test_database_connection(self) -> float:
        """Test database connection and return latency"""
        # Implementation specific to project
        pass

    async def _test_api_client(self) -> float:
        """Test API client and return latency"""
        # Implementation specific to project
        pass

    def _get_current_timestamp(self) -> str:
        """Get current ISO 8601 timestamp"""
        from datetime import datetime
        return datetime.utcnow().isoformat() + "Z"
```

### Runtime Snapshot Management

**Runtime Snapshot Implementation:**

```python
# project/runtime.py
from oneiric.core.runtime import RuntimeSnapshotManager
from mcp_common.health import HealthCheckResponse
import json
import os
from typing import Optional, Dict, Any

class ProjectRuntimeSnapshotManager(RuntimeSnapshotManager):
    def __init__(self, instance_id: Optional[str] = None):
        super().__init__(instance_id=instance_id)
        self.cache_dir = self._get_cache_dir()

    def _get_cache_dir(self) -> str:
        """Get cache directory based on instance ID"""
        if self.instance_id:
            return f".oneiric_cache/{self.instance_id}"
        return ".oneiric_cache"

    async def initialize(self):
        """Initialize runtime snapshots (Crackerjack requirement)"""
        os.makedirs(self.cache_dir, exist_ok=True)

        # Write initial health snapshot
        initial_health = HealthCheckResponse(
            status="HEALTHY",
            components=[],
            timestamp=self._get_current_timestamp()
        )

        health_path = os.path.join(self.cache_dir, "runtime_health.json")
        with open(health_path, "w") as f:
            json.dump(initial_health.dict(), f, indent=2)

        # Write initial telemetry
        initial_telemetry = {
            "metrics": {
                "requests_processed": 0,
                "errors_encountered": 0,
                "average_response_time_ms": 0,
                "uptime_seconds": 0
            },
            "timestamp": self._get_current_timestamp()
        }

        telemetry_path = os.path.join(self.cache_dir, "runtime_telemetry.json")
        with open(telemetry_path, "w") as f:
            json.dump(initial_telemetry, f, indent=2)

    async def update_health_snapshot(self, health_response: HealthCheckResponse):
        """Update health snapshot (Crackerjack requirement)"""
        health_path = os.path.join(self.cache_dir, "runtime_health.json")
        with open(health_path, "w") as f:
            json.dump(health_response.dict(), f, indent=2)

    async def update_telemetry(self, metrics: Dict[str, Any]):
        """Update telemetry data"""
        telemetry_path = os.path.join(self.cache_dir, "runtime_telemetry.json")

        # Read existing telemetry
        if os.path.exists(telemetry_path):
            with open(telemetry_path, "r") as f:
                telemetry = json.load(f)
        else:
            telemetry = {
                "metrics": {},
                "timestamp": self._get_current_timestamp()
            }

        # Update metrics
        telemetry["metrics"].update(metrics)
        telemetry["timestamp"] = self._get_current_timestamp()

        # Write updated telemetry
        with open(telemetry_path, "w") as f:
            json.dump(telemetry, f, indent=2)

    async def cleanup(self):
        """Clean up runtime snapshots"""
        # Remove PID file
        pid_path = os.path.join(self.cache_dir, "server.pid")
        if os.path.exists(pid_path):
            os.remove(pid_path)

        # Note: Keep health and telemetry snapshots for post-mortem analysis

    def _get_current_timestamp(self) -> str:
        """Get current ISO 8601 timestamp"""
        from datetime import datetime
        return datetime.utcnow().isoformat() + "Z"
```

### Configuration Management

**Oneiric Configuration Pattern:**

```python
# project/config.py
from oneiric.core.config import OneiricMCPConfig
from pydantic import Field, validator
from typing import Optional

class ProjectConfig(OneiricMCPConfig):
    # Standard Oneiric fields
    http_port: int = Field(default=3039, env="PROJECT_HTTP_PORT")
    http_host: str = Field(default="127.0.0.1", env="PROJECT_HTTP_HOST")
    enable_telemetry: bool = Field(default=True, env="PROJECT_ENABLE_TELEMETRY")

    # Project-specific fields
    api_key: str = Field(..., env="PROJECT_API_KEY")
    api_secret: Optional[str] = Field(None, env="PROJECT_API_SECRET")
    database_url: str = Field(..., env="PROJECT_DATABASE_URL")

    # Validation
    @validator("http_port")
    def validate_port(cls, v):
        if not (1024 <= v <= 65535):
            raise ValueError("Port must be between 1024 and 65535")
        return v

    class Config:
        env_prefix = "PROJECT_"
        env_file = ".env.project"
        env_file_encoding = "utf-8"
```

______________________________________________________________________

## üìä Compatibility Contract Compliance

### Crackerjack Compliance Checklist

**Mandatory Requirements:**

- [ ] ‚úÖ Use subcommand syntax (`start`, `stop`, etc.)
- [ ] ‚úÖ Remove all legacy CLI flags
- [ ] ‚úÖ Support `--instance-id` for multi-instance
- [ ] ‚úÖ Implement runtime cache (.oneiric_cache/)
- [ ] ‚úÖ Write PID file (server.pid)
- [ ] ‚úÖ Implement health snapshots (runtime_health.json)
- [ ] ‚úÖ Implement telemetry (runtime_telemetry.json)
- [ ] ‚úÖ Use standard exit codes
- [ ] ‚úÖ Auto-generate help output

### Session-Buddy Compliance Checklist

**Mandatory Requirements:**

- [ ] ‚úÖ Use mcp-common health primitives
- [ ] ‚úÖ Implement HealthStatus enum
- [ ] ‚úÖ Implement ComponentHealth schema
- [ ] ‚úÖ Implement HealthCheckResponse schema
- [ ] ‚úÖ Calculate overall status correctly
- [ ] ‚úÖ Include timestamp in health response
- [ ] ‚úÖ Support optional latency and metadata

### Cross-Project Standardization

**Standardization Requirements:**

- [ ] ‚úÖ Consistent CLI command structure
- [ ] ‚úÖ Consistent health schema implementation
- [ ] ‚úÖ Consistent runtime cache structure
- [ ] ‚úÖ Consistent configuration patterns
- [ ] ‚úÖ Consistent error handling
- [ ] ‚úÖ Consistent logging
- [ ] ‚úÖ Consistent observability

______________________________________________________________________

## üß™ Compliance Testing

### Crackerjack Compliance Tests

**Test Requirements:**

```python
# tests/test_crackerjack_compliance.py
import subprocess
import json
import os
import pytest

def test_cli_subcommand_syntax():
    """Test that CLI uses subcommand syntax"""
    # Test that legacy flags are not supported
    result = subprocess.run(["project-mcp", "--start"],
                          capture_output=True, text=True)
    assert result.returncode != 0
    assert "unrecognized arguments" in result.stderr or "Unknown option" in result.stderr

    # Test that subcommands work
    result = subprocess.run(["project-mcp", "start"],
                          capture_output=True, text=True)
    assert result.returncode == 0

def test_instance_isolation():
    """Test instance isolation with --instance-id"""
    # Start server with instance ID
    result = subprocess.run(["project-mcp", "start", "--instance-id", "test-1"],
                          capture_output=True, text=True)
    assert result.returncode == 0

    # Verify instance-specific cache
    assert os.path.exists(".oneiric_cache/test-1/server.pid")
    assert os.path.exists(".oneiric_cache/test-1/runtime_health.json")

def test_runtime_cache_structure():
    """Test runtime cache structure"""
    # Start server
    subprocess.run(["project-mcp", "start"], capture_output=True)

    # Verify cache structure
    assert os.path.exists(".oneiric_cache/server.pid")
    assert os.path.exists(".oneiric_cache/runtime_health.json")
    assert os.path.exists(".oneiric_cache/runtime_telemetry.json")

    # Verify PID file content
    with open(".oneiric_cache/server.pid", "r") as f:
        pid = f.read().strip()
        assert pid.isdigit()

    # Verify health snapshot
    with open(".oneiric_cache/runtime_health.json", "r") as f:
        health = json.load(f)
        assert "status" in health
        assert "components" in health
        assert "timestamp" in health

    # Verify telemetry
    with open(".oneiric_cache/runtime_telemetry.json", "r") as f:
        telemetry = json.load(f)
        assert "metrics" in telemetry
        assert "timestamp" in telemetry

    # Cleanup
    subprocess.run(["project-mcp", "stop"], capture_output=True)

def test_health_command_behavior():
    """Test health command behavior"""
    # Start server
    subprocess.run(["project-mcp", "start"], capture_output=True)

    # Test cached health
    result = subprocess.run(["project-mcp", "health"],
                          capture_output=True, text=True)
    assert result.returncode == 0
    health_cached = json.loads(result.stdout)

    # Test live health probe
    result = subprocess.run(["project-mcp", "health", "--probe"],
                          capture_output=True, text=True)
    assert result.returncode == 0
    health_live = json.loads(result.stdout)

    # Both should have same schema
    assert set(health_cached.keys()) == set(health_live.keys())
    assert "status" in health_cached
    assert "components" in health_cached
    assert "timestamp" in health_cached

    # Cleanup
    subprocess.run(["project-mcp", "stop"], capture_output=True)
```

### Session-Buddy Compliance Tests

**Test Requirements:**

```python
# tests/test_session_buddy_compliance.py
from mcp_common.health import HealthStatus, ComponentHealth, HealthCheckResponse
from project.server import ProjectMCPServer
from project.config import ProjectConfig
import pytest

def test_health_schema_compliance():
    """Test Session-Buddy health schema compliance"""
    config = ProjectConfig()
    server = ProjectMCPServer(config)

    health_response = server.health_check()

    # Verify it's a HealthCheckResponse
    assert isinstance(health_response, HealthCheckResponse)

    # Verify status is HealthStatus enum
    assert isinstance(health_response.status, HealthStatus)
    assert health_response.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED, HealthStatus.UNHEALTHY]

    # Verify components
    assert isinstance(health_response.components, list)
    assert len(health_response.components) > 0

    for component in health_response.components:
        assert isinstance(component, ComponentHealth)
        assert isinstance(component.status, HealthStatus)
        assert isinstance(component.name, str)
        assert isinstance(component.message, str)
        assert component.name  # Not empty
        assert component.message  # Not empty

    # Verify timestamp
    assert isinstance(health_response.timestamp, str)
    assert "Z" in health_response.timestamp or "+" in health_response.timestamp

def test_health_status_calculation():
    """Test health status calculation"""
    config = ProjectConfig()
    server = ProjectMCPServer(config)

    # Test with all healthy components
    healthy_components = [
        ComponentHealth(
            name="component1",
            status=HealthStatus.HEALTHY,
            message="Component 1 healthy"
        ),
        ComponentHealth(
            name="component2",
            status=HealthStatus.HEALTHY,
            message="Component 2 healthy"
        )
    ]

    # Mock the health check to return healthy components
    # (This would require more sophisticated mocking in real implementation)

    # Overall status should be HEALTHY
    # assert health_response.status == HealthStatus.HEALTHY

def test_degraded_status_calculation():
    """Test degraded status calculation"""
    config = ProjectConfig()
    server = ProjectMCPServer(config)

    # Test with one degraded component
    degraded_components = [
        ComponentHealth(
            name="component1",
            status=HealthStatus.HEALTHY,
            message="Component 1 healthy"
        ),
        ComponentHealth(
            name="component2",
            status=HealthStatus.DEGRADED,
            message="Component 2 degraded"
        )
    ]

    # Mock the health check to return degraded components

    # Overall status should be DEGRADED
    # assert health_response.status == HealthStatus.DEGRADED

def test_unhealthy_status_calculation():
    """Test unhealthy status calculation"""
    config = ProjectConfig()
    server = ProjectMCPServer(config)

    # Test with one unhealthy component
    unhealthy_components = [
        ComponentHealth(
            name="component1",
            status=HealthStatus.HEALTHY,
            message="Component 1 healthy"
        ),
        ComponentHealth(
            name="component2",
            status=HealthStatus.UNHEALTHY,
            message="Component 2 unhealthy"
        )
    ]

    # Mock the health check to return unhealthy components

    # Overall status should be UNHEALTHY
    # assert health_response.status == HealthStatus.UNHEALTHY
```

______________________________________________________________________

## üö® Risk Assessment & Mitigation

### Compliance Risks

| Risk Area | Impact | Likelihood | Mitigation Strategy |
|-----------|--------|------------|---------------------|
| **CLI Non-Compliance** | HIGH | MEDIUM | Use Oneiric CLI factory, test thoroughly |
| **Health Schema Issues** | HIGH | MEDIUM | Use mcp-common primitives, validate schema |
| **Cache Structure Problems** | MEDIUM | MEDIUM | Standardize cache management, test cache operations |
| **Status Calculation Errors** | MEDIUM | LOW | Test health status logic, validate calculations |
| **Instance Isolation Issues** | MEDIUM | LOW | Test multi-instance scenarios, verify cache isolation |

### Mitigation Strategies

1. **Use Oneiric Patterns:**

   - Always use `MCPServerCLIFactory` for CLI
   - Use `RuntimeSnapshotManager` for cache management
   - Use mcp-common health primitives

1. **Comprehensive Testing:**

   - Test all CLI commands
   - Test health schema compliance
   - Test runtime cache operations
   - Test multi-instance scenarios

1. **Validation:**

   - Validate health responses
   - Validate cache structure
   - Validate status calculations
   - Validate configuration

1. **Documentation:**

   - Document compliance requirements
   - Provide implementation examples
   - Create testing guides

______________________________________________________________________

## ‚úÖ Success Criteria

### Compliance Success Metrics

**Mandatory Requirements:**

- [ ] ‚úÖ All projects use Oneiric CLI factory
- [ ] ‚úÖ All projects implement Session-Buddy health schema
- [ ] ‚úÖ All projects use standard runtime cache structure
- [ ] ‚úÖ All projects support instance isolation
- [ ] ‚úÖ All projects pass Crackerjack compliance tests
- [ ] ‚úÖ All projects pass Session-Buddy compliance tests
- [ ] ‚úÖ All projects have comprehensive compliance documentation
- [ ] ‚úÖ All projects have compliance testing

### Operational Success Metrics

**Operational Requirements:**

- [ ] ‚úÖ Consistent CLI behavior across projects
- [ ] ‚úÖ Consistent health reporting across projects
- [ ] ‚úÖ Consistent cache management across projects
- [ ] ‚úÖ Consistent configuration patterns across projects
- [ ] ‚úÖ Comprehensive observability across projects
- [ ] ‚úÖ Reliable status reporting across projects
- [ ] ‚úÖ Effective error handling across projects

______________________________________________________________________

## üìÖ Timeline & Resources

### Compliance Implementation Timeline

| Phase | Duration | Focus | Resources |
|-------|----------|-------|-----------|
| **Compliance Documentation** | 1 week | Create this document | Documentation |
| **Implementation** | 2 weeks | Implement compliance | Development |
| **Testing** | 1 week | Test compliance | QA |
| **Validation** | 1 week | Validate compliance | All teams |
| **Maintenance** | Ongoing | Maintain compliance | All teams |

### Resource Allocation

**Weekly Breakdown:**

- Week 1: 5h (Documentation)
- Week 2-3: 15h (Implementation)
- Week 4: 10h (Testing)
- Week 5: 5h (Validation)
- Ongoing: 2h/week (Maintenance)

______________________________________________________________________

## üìù References

### Primary Sources

- **Crackerjack Migration Guide:** `crackerjack/docs/MIGRATION_GUIDE_0.47.0.md`
- **Crackerjack Breaking Changes:** `crackerjack/docs/reference/BREAKING_CHANGES.md`
- **Crackerjack Oneiric Plan:** `crackerjack/docs/archive/implementation-plans/ONEIRIC_MIGRATION_EXECUTION_PLAN.md`
- **Session-Buddy API Reference:** `session-buddy/docs/reference/API_REFERENCE.md`
- **MCP-Common Health:** `mcp-common/health.py`

### Implementation References

- **Oneiric CLI Factory:** `oneiric/core/cli.py`
- **Oneiric Server:** `oneiric/core/server.py`
- **Oneiric Runtime:** `oneiric/core/runtime.py`
- **Oneiric Config:** `oneiric/core/config.py`
- **Oneiric Health:** `oneiric/core/health.py`

### Migration References

- **Migration Plan:** `MCP_SERVER_MIGRATION_PLAN.md`
- **Tracking Dashboard:** `MIGRATION_TRACKING_DASHBOARD.md`
- **CLI Guide:** `CLI_COMMAND_MAPPING_GUIDE.md`
- **Test Baselines:** `TEST_COVERAGE_BASELINES.md`
- **Rollback Procedures:** `ROLLBACK_PROCEDURES_TEMPLATE.md`

______________________________________________________________________

## üéØ Next Steps

### Immediate Actions

1. **Complete Operational Model Documentation:**

   - [ ] ‚úÖ Create operational model document (this document)
   - [ ] ‚è≥ Add project-specific implementation examples
   - [ ] ‚è≥ Create compliance testing suite
   - [ ] ‚è≥ Document testing procedures

1. **Integrate with Migration Plan:**

   - [ ] ‚è≥ Add operational model to migration plan
   - [ ] ‚è≥ Update tracking dashboard with compliance status
   - [ ] ‚è≥ Add compliance testing to CI/CD pipelines

1. **Implementation Preparation:**

   - [ ] ‚è≥ Create implementation templates
   - [ ] ‚è≥ Define compliance requirements per project
   - [ ] ‚è≥ Set up compliance testing environments

### Long-Term Actions

1. **Compliance Implementation:**

   - [ ] ‚è≥ Implement Crackerjack compliance for all projects
   - [ ] ‚è≥ Implement Session-Buddy compliance for all projects
   - [ ] ‚è≥ Add comprehensive compliance testing

1. **Compliance Monitoring:**

   - [ ] ‚è≥ Monitor compliance during migration
   - [ ] ‚è≥ Address any compliance issues
   - [ ] ‚è≥ Maintain compliance documentation

1. **Quality Improvement:**

   - [ ] ‚è≥ Improve compliance testing
   - [ ] ‚è≥ Add automated compliance checks
   - [ ] ‚è≥ Enhance operational documentation

______________________________________________________________________

**Document Status:** ‚úÖ COMPLETED
**Last Updated:** 2025-12-30
**Next Review:** 2026-01-01
**Owner:** [Your Name]
**Review Frequency:** Weekly during migration
