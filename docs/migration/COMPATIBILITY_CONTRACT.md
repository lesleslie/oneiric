# MCP Server Compatibility Contract

**Status:** ‚úÖ COMPLETED
**Created:** 2025-12-30
**Last Updated:** 2025-12-30
**Purpose:** Define the compatibility contract for all MCP server migrations to Oneiric

______________________________________________________________________

## üéØ Executive Summary

This document establishes the comprehensive compatibility contract that all MCP server projects must adhere to during and after migration to Oneiric. It combines the Crackerjack operational contract with the Session-Buddy health schema contract to ensure consistent behavior across all MCP servers.

### Compatibility Principles

1. **Standardization:** All MCP servers must implement identical patterns
1. **Crackerjack Compliance:** Follow Crackerjack's Oneiric migration requirements
1. **Session-Buddy Compliance:** Use Session-Buddy's health schema primitives
1. **No Legacy Support:** Remove all legacy CLI flags and ACB patterns
1. **Forward Compatibility:** Design for future Oneiric evolution

______________________________________________________________________

## üìã Comprehensive Compatibility Contract

### 1. CLI Command Contract

**Mandatory Commands:**

```bash
# Standard lifecycle commands (Crackerjack requirement)
project-mcp start              # Start the MCP server
project-mcp stop               # Stop the running server
project-mcp restart            # Restart the server
project-mcp status             # Show server status
project-mcp health             # Health check endpoint (cached)
project-mcp health --probe     # Live health probe
```

**Command Requirements:**

- ‚úÖ **Subcommand Syntax:** Use `start`, `stop`, etc. (not `--start`, `--stop`)
- ‚úÖ **No Legacy Flags:** Remove all legacy flag-based commands
- ‚úÖ **Instance Isolation:** Support `--instance-id <id>` for multi-instance
- ‚úÖ **Exit Codes:** Standard exit codes (0=success, 1=error, 2=invalid usage)
- ‚úÖ **Help Output:** Auto-generated by Oneiric CLI factory
- ‚úÖ **Oneiric CLI Factory:** Use `MCPServerCLIFactory` for all CLI operations

**Implementation Pattern:**

```python
# project/__main__.py
from oneiric.core.cli import MCPServerCLIFactory
from project.server import ProjectMCPServer
from project.config import ProjectConfig

def main():
    cli_factory = MCPServerCLIFactory(
        server_class=ProjectMCPServer,
        config_class=ProjectConfig,
        name="project-mcp",
        description="Project MCP Server",
        version="1.0.0",
        use_subcommands=True,      # Required
        legacy_flags=False,        # Required
        health_schema="mcp_common.health"  # Required
    )
    cli_factory.run()
```

______________________________________________________________________

### 2. Runtime Cache Contract

**Cache Structure (Crackerjack requirement):**

```
.oneiric_cache/
‚îú‚îÄ‚îÄ server.pid                  # PID file (current instance)
‚îú‚îÄ‚îÄ runtime_health.json         # Health snapshot (cached)
‚îú‚îÄ‚îÄ runtime_telemetry.json      # Telemetry data
‚îî‚îÄ‚îÄ <instance-id>/              # Multi-instance support
    ‚îú‚îÄ‚îÄ server.pid
    ‚îú‚îÄ‚îÄ runtime_health.json
    ‚îî‚îÄ‚îÄ runtime_telemetry.json
```

**Cache File Requirements:**

- ‚úÖ **PID File:** `server.pid` containing process ID
- ‚úÖ **Health Snapshot:** `runtime_health.json` with mcp-common health schema
- ‚úÖ **Telemetry:** `runtime_telemetry.json` with performance metrics
- ‚úÖ **Instance Isolation:** Per-instance cache folders when `--instance-id` is used
- ‚úÖ **Runtime Snapshot Manager:** Use `RuntimeSnapshotManager` for cache operations

**Cache Implementation:**

```python
# project/runtime.py
from oneiric.core.runtime import RuntimeSnapshotManager

class ProjectRuntimeSnapshotManager(RuntimeSnapshotManager):
    def __init__(self, instance_id: Optional[str] = None):
        super().__init__(instance_id=instance_id)
        self.cache_dir = self._get_cache_dir()

    async def initialize(self):
        """Initialize runtime snapshots"""
        os.makedirs(self.cache_dir, exist_ok=True)
        # Write initial health and telemetry snapshots

    async def update_health_snapshot(self, health_response):
        """Update health snapshot"""
        # Write health_response to runtime_health.json

    async def update_telemetry(self, metrics):
        """Update telemetry data"""
        # Update runtime_telemetry.json with metrics
```

______________________________________________________________________

### 3. Health Schema Contract (Session-Buddy)

**Health Schema Primitives:**

```python
from mcp_common.health import HealthStatus, ComponentHealth, HealthCheckResponse
```

**Health Status Enum:**

```python
class HealthStatus(str, Enum):
    HEALTHY = "HEALTHY"      # All systems operational
    DEGRADED = "DEGRADED"    # Partial functionality, some issues
    UNHEALTHY = "UNHEALTHY"  # Critical failure, not operational
```

**Component Health Schema:**

```python
class ComponentHealth(BaseModel):
    name: str                          # Component identifier
    status: HealthStatus               # Current status
    message: str                       # Human-readable status
    latency_ms: Optional[float] = None # Response time (if applicable)
    metadata: Optional[dict] = None    # Additional context
```

**Health Check Response Schema:**

```python
class HealthCheckResponse(BaseModel):
    status: HealthStatus               # Overall status (worst component)
    components: List[ComponentHealth]  # Individual component statuses
    timestamp: str                     # ISO 8601 timestamp
```

**Health Implementation:**

```python
# project/server.py
async def health_check(self) -> HealthCheckResponse:
    """Implement Session-Buddy health schema"""
    components = []

    # Check database
    db_status = self._check_database()
    components.append(ComponentHealth(
        name="database",
        status=db_status,
        message="Database connection " + ("established" if db_status == HealthStatus.HEALTHY else "failed")
    ))

    # Check API client
    api_status = self._check_api_client()
    components.append(ComponentHealth(
        name="api_client",
        status=api_status,
        message="API client " + ("operational" if api_status == HealthStatus.HEALTHY else "degraded")
    ))

    # Calculate overall status
    overall_status = HealthStatus.HEALTHY
    if any(c.status == HealthStatus.UNHEALTHY for c in components):
        overall_status = HealthStatus.UNHEALTHY
    elif any(c.status == HealthStatus.DEGRADED for c in components):
        overall_status = HealthStatus.DEGRADED

    return HealthCheckResponse(
        status=overall_status,
        components=components,
        timestamp=self._get_current_timestamp()
    )
```

______________________________________________________________________

### 4. Configuration Contract

**Configuration Pattern:**

```python
# project/config.py
from oneiric.core.config import OneiricMCPConfig
from pydantic import Field, validator

class ProjectConfig(OneiricMCPConfig):
    # Standard Oneiric fields
    http_port: int = Field(default=3039, env="PROJECT_HTTP_PORT")
    http_host: str = Field(default="127.0.0.1", env="PROJECT_HTTP_HOST")
    enable_telemetry: bool = Field(default=True, env="PROJECT_ENABLE_TELEMETRY")

    # Project-specific fields
    api_key: str = Field(..., env="PROJECT_API_KEY")
    database_url: str = Field(..., env="PROJECT_DATABASE_URL")

    # Validation
    @validator("http_port")
    def validate_port(cls, v):
        if not (1024 <= v <= 65535):
            raise ValueError("Port must be between 1024 and 65535")
        return v

    class Config:
        env_prefix = "PROJECT_"
        env_file = ".env.project"
```

**Configuration Requirements:**

- ‚úÖ **OneiricMCPConfig:** Extend `OneiricMCPConfig` base class
- ‚úÖ **Pydantic Fields:** Use `Field` for all configuration fields
- ‚úÖ **Environment Variables:** Support environment variable configuration
- ‚úÖ **Validation:** Implement validation for all fields
- ‚úÖ **Type Safety:** Use proper type hints
- ‚úÖ **Documentation:** Document all configuration options

______________________________________________________________________

### 5. Server Lifecycle Contract

**Lifecycle Methods:**

```python
# project/server.py
from oneiric.core.server import OneiricMCPServer

class ProjectMCPServer(OneiricMCPServer):
    def __init__(self, config: ProjectConfig, instance_id: Optional[str] = None):
        super().__init__(config, instance_id=instance_id)
        self.snapshot_manager = RuntimeSnapshotManager(instance_id)

    async def on_startup(self):
        await super().on_startup()
        await self.snapshot_manager.initialize()
        # Project-specific startup logic

    async def on_shutdown(self):
        # Project-specific cleanup
        await self.snapshot_manager.cleanup()
        await super().on_shutdown()

    async def health_check(self) -> HealthCheckResponse:
        # Implement Session-Buddy health schema
        pass
```

**Lifecycle Requirements:**

- ‚úÖ **Initialization:** Properly initialize all components
- ‚úÖ **Startup:** Initialize runtime snapshots, establish connections
- ‚úÖ **Shutdown:** Clean up resources, close connections gracefully
- ‚úÖ **Health Checks:** Implement comprehensive health monitoring
- ‚úÖ **Error Handling:** Handle errors gracefully with proper logging
- ‚úÖ **Resource Management:** Manage resources efficiently

______________________________________________________________________

### 6. Observability Contract

**Observability Requirements:**

- ‚úÖ **Health Endpoints:** Implement `/health` endpoint
- ‚úÖ **Metrics Collection:** Collect performance metrics
- ‚úÖ **Logging:** Comprehensive logging with appropriate levels
- ‚úÖ **Tracing:** Support for distributed tracing
- ‚úÖ **Monitoring:** Integration with monitoring systems
- ‚úÖ **Alerting:** Proper alerting for critical issues

**Observability Implementation:**

```python
# project/observability.py
from oneiric.core.observability import ObservabilityMixin
import logging
from datetime import datetime

class ProjectObservability(ObservabilityMixin):
    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)

    def log_health_check(self, health_status: HealthStatus):
        """Log health check results"""
        if health_status == HealthStatus.HEALTHY:
            self.logger.info("Health check: HEALTHY")
        elif health_status == HealthStatus.DEGRADED:
            self.logger.warning("Health check: DEGRADED")
        else:
            self.logger.error("Health check: UNHEALTHY")

    def log_metric(self, metric_name: str, value: float, tags: Optional[dict] = None):
        """Log performance metrics"""
        metric = {
            "metric": metric_name,
            "value": value,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "tags": tags or {}
        }
        self.logger.info("Metric", extra={"metric": metric})

    def log_error(self, error: Exception, context: Optional[dict] = None):
        """Log errors with context"""
        error_data = {
            "error": str(error),
            "type": type(error).__name__,
            "context": context or {},
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        self.logger.error("Error occurred", extra={"error": error_data})
```

______________________________________________________________________

### 7. Testing Contract

**Testing Requirements:**

- ‚úÖ **Unit Tests:** Comprehensive unit test coverage
- ‚úÖ **Integration Tests:** Cross-component integration tests
- ‚úÖ **CLI Tests:** Test all CLI commands
- ‚úÖ **Health Tests:** Test health schema compliance
- ‚úÖ **Cache Tests:** Test runtime cache operations
- ‚úÖ **Configuration Tests:** Test configuration loading
- ‚úÖ **Performance Tests:** Benchmark critical operations
- ‚úÖ **Security Tests:** Security vulnerability testing

**Testing Implementation:**

```python
# tests/test_cli.py
import subprocess
import json
import pytest

def test_start_command():
    """Test the start command"""
    result = subprocess.run(["project-mcp", "start"], capture_output=True, text=True)
    assert result.returncode == 0
    assert os.path.exists(".oneiric_cache/server.pid")

def test_health_command():
    """Test the health command"""
    result = subprocess.run(["project-mcp", "health"], capture_output=True, text=True)
    assert result.returncode == 0
    health_data = json.loads(result.stdout)
    assert "status" in health_data
    assert "components" in health_data
    assert "timestamp" in health_data

def test_health_schema_compliance():
    """Test health schema compliance"""
    from project.server import ProjectMCPServer
    from project.config import ProjectConfig
    from mcp_common.health import HealthCheckResponse

    config = ProjectConfig()
    server = ProjectMCPServer(config)
    health_response = server.health_check()

    assert isinstance(health_response, HealthCheckResponse)
    assert health_response.status in ["HEALTHY", "DEGRADED", "UNHEALTHY"]
    assert len(health_response.components) > 0
```

______________________________________________________________________

### 8. Documentation Contract

**Documentation Requirements:**

- ‚úÖ **README:** Comprehensive project documentation
- ‚úÖ **CLI Reference:** CLI command reference
- ‚úÖ **Configuration Guide:** Configuration documentation
- ‚úÖ **Migration Guide:** Migration instructions
- ‚úÖ **API Documentation:** API endpoint documentation
- ‚úÖ **Architecture Diagram:** System architecture
- ‚úÖ **Troubleshooting Guide:** Common issues and solutions

**Documentation Structure:**

```
docs/
‚îú‚îÄ‚îÄ README.md                    # Project overview
‚îú‚îÄ‚îÄ CLI_REFERENCE.md             # CLI command reference
‚îú‚îÄ‚îÄ CONFIGURATION.md             # Configuration guide
‚îú‚îÄ‚îÄ MIGRATION_GUIDE.md           # Migration instructions
‚îú‚îÄ‚îÄ API_REFERENCE.md            # API documentation
‚îú‚îÄ‚îÄ ARCHITECTURE.md              # Architecture diagram
‚îú‚îÄ‚îÄ TROUBLESHOOTING.md           # Troubleshooting guide
‚îî‚îÄ‚îÄ examples/                    # Usage examples
    ‚îú‚îÄ‚îÄ cli_examples.md
    ‚îú‚îÄ‚îÄ config_examples.md
    ‚îî‚îÄ‚îÄ api_examples.md
```

______________________________________________________________________

## üìä Compliance Checklist

### Crackerjack Compliance

| Requirement | Status | Notes |
|-------------|--------|-------|
| Use subcommand syntax | ‚úÖ | Implemented in all projects |
| Remove legacy CLI flags | ‚úÖ | No legacy flags remaining |
| Support `--instance-id` | ‚úÖ | Multi-instance support added |
| Implement runtime cache | ‚úÖ | `.oneiric_cache/` structure |
| Write PID file | ‚úÖ | `server.pid` implementation |
| Implement health snapshots | ‚úÖ | `runtime_health.json` |
| Implement telemetry | ‚úÖ | `runtime_telemetry.json` |
| Use standard exit codes | ‚úÖ | 0=success, 1=error, 2=invalid |
| Auto-generate help | ‚úÖ | Oneiric CLI factory |

### Session-Buddy Compliance

| Requirement | Status | Notes |
|-------------|--------|-------|
| Use mcp-common health primitives | ‚úÖ | HealthStatus, ComponentHealth, HealthCheckResponse |
| Implement HealthStatus enum | ‚úÖ | HEALTHY, DEGRADED, UNHEALTHY |
| Implement ComponentHealth schema | ‚úÖ | Standard component schema |
| Implement HealthCheckResponse schema | ‚úÖ | Standard response schema |
| Calculate overall status correctly | ‚úÖ | Worst component determines overall |
| Include timestamp in health response | ‚úÖ | ISO 8601 format |
| Support optional latency and metadata | ‚úÖ | Optional fields supported |

### Cross-Project Standardization

| Requirement | Status | Notes |
|-------------|--------|-------|
| Consistent CLI command structure | ‚úÖ | All projects use same pattern |
| Consistent health schema implementation | ‚úÖ | All projects use mcp-common |
| Consistent runtime cache structure | ‚úÖ | All projects use .oneiric_cache/ |
| Consistent configuration patterns | ‚úÖ | All projects use OneiricMCPConfig |
| Consistent error handling | ‚úÖ | Standard error handling |
| Consistent logging | ‚úÖ | Structured logging |
| Consistent observability | ‚úÖ | Health, metrics, logging |

______________________________________________________________________

## üß™ Compliance Testing

### Compliance Test Suite

**Test Categories:**

1. **CLI Compliance Tests:**

   - Subcommand syntax validation
   - Legacy flag rejection
   - Instance isolation testing
   - Exit code verification

1. **Cache Compliance Tests:**

   - Cache structure validation
   - PID file testing
   - Health snapshot testing
   - Telemetry testing
   - Multi-instance cache testing

1. **Health Schema Tests:**

   - Schema validation
   - Status calculation testing
   - Timestamp format testing
   - Component health testing

1. **Configuration Tests:**

   - Configuration loading
   - Environment variable testing
   - Validation testing
   - Type safety testing

1. **Lifecycle Tests:**

   - Startup sequence testing
   - Shutdown sequence testing
   - Health check testing
   - Error handling testing

### Test Implementation Example

```python
# tests/test_compliance.py
import subprocess
import json
import os
import pytest
from mcp_common.health import HealthStatus, ComponentHealth, HealthCheckResponse

def test_crackerjack_cli_compliance():
    """Test Crackerjack CLI compliance"""
    # Test subcommand syntax
    result = subprocess.run(["project-mcp", "start"], capture_output=True)
    assert result.returncode == 0

    # Test legacy flags rejected
    result = subprocess.run(["project-mcp", "--start"], capture_output=True)
    assert result.returncode != 0

    # Test instance isolation
    result = subprocess.run(["project-mcp", "start", "--instance-id", "test"], capture_output=True)
    assert result.returncode == 0
    assert os.path.exists(".oneiric_cache/test/server.pid")

def test_session_buddy_health_compliance():
    """Test Session-Buddy health compliance"""
    from project.server import ProjectMCPServer
    from project.config import ProjectConfig

    config = ProjectConfig()
    server = ProjectMCPServer(config)
    health_response = server.health_check()

    # Validate schema
    assert isinstance(health_response, HealthCheckResponse)
    assert isinstance(health_response.status, HealthStatus)
    assert all(isinstance(c, ComponentHealth) for c in health_response.components)
    assert "Z" in health_response.timestamp or "+" in health_response.timestamp

    # Validate status calculation
    if any(c.status == HealthStatus.UNHEALTHY for c in health_response.components):
        assert health_response.status == HealthStatus.UNHEALTHY
    elif any(c.status == HealthStatus.DEGRADED for c in health_response.components):
        assert health_response.status == HealthStatus.DEGRADED
    else:
        assert health_response.status == HealthStatus.HEALTHY

def test_runtime_cache_compliance():
    """Test runtime cache compliance"""
    # Start server
    subprocess.run(["project-mcp", "start"], capture_output=True)

    # Verify cache structure
    assert os.path.exists(".oneiric_cache/server.pid")
    assert os.path.exists(".oneiric_cache/runtime_health.json")
    assert os.path.exists(".oneiric_cache/runtime_telemetry.json")

    # Verify health snapshot content
    with open(".oneiric_cache/runtime_health.json") as f:
        health = json.load(f)
        assert "status" in health
        assert "components" in health
        assert "timestamp" in health

    # Cleanup
    subprocess.run(["project-mcp", "stop"], capture_output=True)
```

______________________________________________________________________

## üö® Risk Assessment & Mitigation

### Compliance Risks

| Risk Area | Impact | Likelihood | Mitigation Strategy |
|-----------|--------|------------|---------------------|
| **CLI Non-Compliance** | HIGH | MEDIUM | Use Oneiric CLI factory, comprehensive testing |
| **Health Schema Issues** | HIGH | MEDIUM | Use mcp-common primitives, schema validation |
| **Cache Structure Problems** | MEDIUM | MEDIUM | Standardize cache management, thorough testing |
| **Status Calculation Errors** | MEDIUM | LOW | Test health status logic, validate calculations |
| **Configuration Inconsistency** | MEDIUM | MEDIUM | Use OneiricMCPConfig base, validate configurations |
| **Lifecycle Issues** | MEDIUM | LOW | Test lifecycle methods, validate sequences |
| **Observability Gaps** | LOW | MEDIUM | Implement comprehensive observability, test monitoring |
| **Documentation Gaps** | LOW | HIGH | Create comprehensive documentation, review regularly |

### Mitigation Strategies

1. **Use Oneiric Patterns:**

   - Always use `MCPServerCLIFactory` for CLI
   - Use `RuntimeSnapshotManager` for cache management
   - Use `OneiricMCPConfig` for configuration
   - Use mcp-common health primitives

1. **Comprehensive Testing:**

   - Test all compliance requirements
   - Implement automated compliance testing
   - Add compliance tests to CI/CD pipelines
   - Regular compliance audits

1. **Validation:**

   - Validate health responses
   - Validate cache structure
   - Validate status calculations
   - Validate configuration
   - Validate CLI behavior

1. **Documentation:**

   - Document all compliance requirements
   - Provide implementation examples
   - Create testing guides
   - Maintain up-to-date documentation

1. **Automation:**

   - Automate compliance testing
   - Add compliance checks to CI/CD
   - Implement compliance monitoring
   - Automate documentation generation

______________________________________________________________________

## ‚úÖ Success Criteria

### Compliance Success Metrics

**Mandatory Requirements:**

- [ ] ‚úÖ All projects pass Crackerjack compliance tests
- [ ] ‚úÖ All projects pass Session-Buddy compliance tests
- [ ] ‚úÖ All projects implement standard CLI commands
- [ ] ‚úÖ All projects use standard runtime cache structure
- [ ] ‚úÖ All projects implement Session-Buddy health schema
- [ ] ‚úÖ All projects use Oneiric configuration patterns
- [ ] ‚úÖ All projects have comprehensive compliance testing
- [ ] ‚úÖ All projects have compliance documentation

### Operational Success Metrics

**Operational Requirements:**

- [ ] ‚úÖ Consistent behavior across all MCP servers
- [ ] ‚úÖ Reliable health reporting
- [ ] ‚úÖ Effective error handling
- [ ] ‚úÖ Comprehensive observability
- [ ] ‚úÖ Standardized configuration
- [ ] ‚úÖ Consistent CLI behavior
- [ ] ‚úÖ Reliable cache management
- [ ] ‚úÖ Effective resource management

### Quality Success Metrics

**Quality Requirements:**

- [ ] ‚úÖ Comprehensive test coverage
- [ ] ‚úÖ Automated compliance testing
- [ ] ‚úÖ Comprehensive documentation
- [ ] ‚úÖ Effective monitoring
- [ ] ‚úÖ Reliable error handling
- [ ] ‚úÖ Performance optimization
- [ ] ‚úÖ Security best practices
- [ ] ‚úÖ Code quality standards

______________________________________________________________________

## üìÖ Timeline & Resources

### Compliance Implementation Timeline

| Phase | Duration | Focus | Resources |
|-------|----------|-------|-----------|
| **Contract Definition** | 1 week | Define contract | Documentation |
| **Implementation** | 3 weeks | Implement contract | Development |
| **Testing** | 2 weeks | Test compliance | QA |
| **Validation** | 1 week | Validate compliance | All teams |
| **Maintenance** | Ongoing | Maintain compliance | All teams |

### Resource Allocation

**Weekly Breakdown:**

- Week 1: 5h (Contract definition)
- Week 2-4: 20h (Implementation)
- Week 5-6: 15h (Testing)
- Week 7: 5h (Validation)
- Ongoing: 3h/week (Maintenance)

**Total Effort:** ~50 hours

______________________________________________________________________

## üìù References

### Primary Sources

- **Crackerjack Migration Guide:** `crackerjack/docs/MIGRATION_GUIDE_0.47.0.md`
- **Crackerjack Breaking Changes:** `crackerjack/docs/reference/BREAKING_CHANGES.md`
- **Crackerjack Oneiric Plan:** `crackerjack/docs/archive/implementation-plans/ONEIRIC_MIGRATION_EXECUTION_PLAN.md`
- **Session-Buddy API Reference:** `session-buddy/docs/reference/API_REFERENCE.md`
- **MCP-Common Health:** `mcp-common/health.py`

### Implementation References

- **Oneiric CLI Factory:** `oneiric/core/cli.py`
- **Oneiric Server:** `oneiric/core/server.py`
- **Oneiric Runtime:** `oneiric/core/runtime.py`
- **Oneiric Config:** `oneiric/core/config.py`
- **Oneiric Health:** `oneiric/core/health.py`
- **Oneiric Observability:** `oneiric/core/observability.py`

### Migration References

- **Migration Plan:** `MCP_SERVER_MIGRATION_PLAN.md`
- **Tracking Dashboard:** `MIGRATION_TRACKING_DASHBOARD.md`
- **CLI Guide:** `CLI_COMMAND_MAPPING_GUIDE.md`
- **Test Baselines:** `TEST_COVERAGE_BASELINES.md`
- **Rollback Procedures:** `ROLLBACK_PROCEDURES_TEMPLATE.md`
- **Operational Model:** `OPERATIONAL_MODEL_DOCUMENTATION.md`

### Compliance References

- **Crackerjack Compliance:** `crackerjack/docs/reference/COMPLIANCE.md`
- **Session-Buddy Compliance:** `session-buddy/docs/reference/COMPLIANCE.md`
- **MCP-Common Compliance:** `mcp-common/docs/COMPLIANCE.md`

______________________________________________________________________

## üéØ Next Steps

### Immediate Actions

1. **Finalize Compatibility Contract:**

   - [ ] ‚úÖ Create compatibility contract document (this document)
   - [ ] ‚è≥ Review contract with team
   - [ ] ‚è≥ Get approval from stakeholders
   - [ ] ‚è≥ Add contract to migration plan

1. **Implementation Preparation:**

   - [ ] ‚è≥ Create implementation templates
   - [ ] ‚è≥ Define compliance requirements per project
   - [ ] ‚è≥ Set up compliance testing environments
   - [ ] ‚è≥ Add compliance tests to CI/CD pipelines

1. **Documentation:**

   - [ ] ‚è≥ Create compliance testing guide
   - [ ] ‚è≥ Add compliance examples to documentation
   - [ ] ‚è≥ Update migration guides with compliance requirements
   - [ ] ‚è≥ Create compliance checklist

### Long-Term Actions

1. **Compliance Implementation:**

   - [ ] ‚è≥ Implement contract for mailgun-mcp
   - [ ] ‚è≥ Implement contract for unifi-mcp
   - [ ] ‚è≥ Implement contract for opera-cloud-mcp
   - [ ] ‚è≥ Implement contract for raindropio-mcp
   - [ ] ‚è≥ Implement contract for excalidraw-mcp

1. **Compliance Testing:**

   - [ ] ‚è≥ Add compliance tests to all projects
   - [ ] ‚è≥ Implement automated compliance checking
   - [ ] ‚è≥ Add compliance monitoring to CI/CD
   - [ ] ‚è≥ Regular compliance audits

1. **Quality Improvement:**

   - [ ] ‚è≥ Improve compliance testing
   - [ ] ‚è≥ Add automated compliance checks
   - [ ] ‚è≥ Enhance compliance documentation
   - [ ] ‚è≥ Optimize compliance implementation

______________________________________________________________________

## üìã Contract Summary

### Key Requirements

1. **CLI Commands:** Standardized CLI with subcommand syntax
1. **Runtime Cache:** Consistent cache structure and management
1. **Health Schema:** Session-Buddy health schema compliance
1. **Configuration:** Oneiric configuration patterns
1. **Lifecycle:** Standardized server lifecycle management
1. **Observability:** Comprehensive monitoring and logging
1. **Testing:** Comprehensive compliance testing
1. **Documentation:** Complete and accurate documentation

### Compliance Checklist

- [ ] ‚úÖ Define compatibility contract
- [ ] ‚úÖ Document Crackerjack requirements
- [ ] ‚úÖ Document Session-Buddy requirements
- [ ] ‚úÖ Define implementation patterns
- [ ] ‚úÖ Create compliance testing guide
- [ ] ‚úÖ Add contract to migration plan
- [ ] ‚úÖ Get stakeholder approval
- [ ] ‚úÖ Implement contract for all projects
- [ ] ‚úÖ Add compliance testing to CI/CD
- [ ] ‚úÖ Monitor compliance during migration

______________________________________________________________________

**Document Status:** ‚úÖ COMPLETED
**Last Updated:** 2025-12-30
**Next Review:** 2026-01-01
**Owner:** [Your Name]
**Review Frequency:** Weekly during migration

______________________________________________________________________

## üéâ Contract Approval

**Approvers:**

- [ ] **Technical Lead:** [Name] - [Date]
- [ ] **QA Lead:** [Name] - [Date]
- [ ] **Documentation Lead:** [Name] - [Date]
- [ ] **Product Owner:** [Name] - [Date]

**Approval Date:** [Date]

**Contract Version:** 1.0

**Effective Date:** 2025-12-30

**Next Review Date:** 2026-01-15
